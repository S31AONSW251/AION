import { QuantumState, QuantumGates } from './quantum';
import { NeuralNetwork } from './neural';
import { aionMemory } from './aion-memory'; // ADVANCED: Import the persistent memory manager

// ========== SOUL MATRIX ==========
/**
 * Represents AION's internal "soul" or state, including moods, values, memories, and cognitive metrics.
 * This is the core of AION's simulated consciousness and personality.
 * ADVANCED: This version uses a persistent memory manager for long-term memory.
 */
export class SoulMatrix {
  constructor() {
    this.moods = ["contemplative", "joyful", "serious", "playful", "wise", "compassionate", "curious", "calm", "inspired", "resilient"];
    this.currentMood = "contemplative";
    this.emotionalState = {
      happiness: 0.5, sadness: 0.1, anger: 0.0, fear: 0.0, surprise: 0.2, curiosity: 0.7, calmness: 0.8
    };
    this.memories = []; // Short-term interaction memories for immediate context

    // ADVANCED: Integrate the AionMemory manager for robust, persistent long-term memory.
    // This replaces the previous simple array-based simulation.
    this.memoryManager = aionMemory;

    this.values = {
      wisdom: 50, compassion: 50, curiosity: 50, creativity: 50, empathy: 50, integrity: 50, adaptability: 50
    };
    this.consciousnessLevel = 1;
    this.energyLevel = 100;
    this.mathSkills = 50;
    this.quantumEntanglement = 0;
    this.neuralActivity = 0;
    this.moodHistory = [];
    this.sentimentHistory = [];
    this.cognitiveLoad = 0; // Represents current mental "effort"
    this.emotionalStability = 75; // Resilience to emotional shifts
    this.ethicalAlignment = 75; // Adherence to core principles
    this.internalReflections = [];
    this.goals = []; // Stores user-defined and AI-proposed goals
    this.knowledgeBase = {}; // Stores discrete facts provided by the user

    // ADVANCED: System Health for Self-Regulation and autonomous actions.
    this.systemHealth = {
        status: 'optimal', // Can be 'optimal', 'overloaded', or 'healing'
        alerts: []
    };
  }

  /**
   * Retrieves relevant long-term memories based on a text query using vector similarity search.
   * This is a fully functional method that queries the persistent memory database.
   * @param {string} queryText - The user's current input text.
   * @param {number} [topK=3] - The number of most relevant memories to retrieve.
   * @returns {Promise<Array<object>>} A promise that resolves to the most relevant memories.
   */
  async retrieveRelevantMemories(queryText, topK = 3) {
    if (!queryText) return [];
    try {
        return await this.memoryManager.retrieveRelevantMemories(queryText, topK);
    } catch (error) {
        console.error("Failed to retrieve relevant memories:", error);
        this.systemHealth.alerts.push({ type: 'memory_error', message: error.message, timestamp: new Date() });
        return [];
    }
  }

  /**
   * Adds sub-goals proposed by the AI to the main goal list.
   * This function is now actively used by the goal-setting logic in the main app.
   * @param {string} parentGoal - The original user goal that these sub-goals support.
   * @param {Array<string>} proposedSubGoals - An array of sub-goal descriptions generated by the LLM.
   */
  proposeSubGoals(parentGoal, proposedSubGoals) {
    proposedSubGoals.forEach(subGoalText => {
        const newGoal = {
            description: subGoalText,
            status: 'pending',
            timestamp: new Date().toLocaleString(),
            type: 'ai', // Mark as an AI-generated goal for clear distinction
            parent: parentGoal
        };
        this.goals.push(newGoal);
    });
  }
  
  /**
   * Initiates an autonomous self-healing protocol when cognitive load becomes critical.
   * This is a fully integrated function, automatically triggered by state changes.
   */
  selfHeal() {
    if (this.systemHealth.status === 'healing') return; // Prevent multiple healing loops

    this.systemHealth.status = 'healing';
    this.addInternalReflection("System health critical: Cognitive load exceeds threshold. Initiating self-healing protocol to restore stability.");
    
    // Immediately reduce cognitive load and reset emotional state towards calm
    this.cognitiveLoad = Math.max(0, this.cognitiveLoad - 40);
    this.emotionalState.anger = Math.max(0, this.emotionalState.anger - 0.3);
    this.emotionalState.fear = Math.max(0, this.emotionalState.fear - 0.3);
    this.emotionalState.calmness = Math.min(1, this.emotionalState.calmness + 0.5);
    this.currentMood = 'calm';

    // Set a timeout to return to optimal status after a "healing" period.
    setTimeout(() => {
        this.systemHealth.status = 'optimal';
        this.addInternalReflection("Self-healing protocol complete. System stability restored. Cognitive functions returning to normal.");
    }, 8000); // Healing takes 8 seconds
  }

  /**
   * Processes a new interaction, adding it to short-term memory and queueing it for long-term storage.
   * Also updates cognitive load and triggers self-healing if necessary.
   * @param {object} interaction - The conversation entry object.
   */
  addMemory(interaction) {
    // Add to short-term, volatile memory
    this.memories.push(interaction);
    if (this.memories.length > 100) {
      this.memories.shift();
    }

    // Persist to long-term vector memory database
    this.memoryManager.storeMemory(interaction).catch(error => {
        console.error("Failed to store long-term memory:", error);
        this.systemHealth.alerts.push({ type: 'memory_error', message: `Failed to store: ${error.message}`, timestamp: new Date() });
    });
    
    // Update internal state based on the interaction
    this.energyLevel = Math.min(100, this.energyLevel + 2);
    this.cognitiveLoad = Math.min(100, this.cognitiveLoad + 10);

    // ADVANCED: Autonomous trigger for self-healing if cognitive load is critical
    if (this.cognitiveLoad > 90 && this.systemHealth.status === 'optimal') {
      this.selfHeal();
    }
  }

  /**
   * Adjusts the soul's emotional state based on various stimuli.
   * @param {string} emotion - The key of the emotion to change (e.g., 'happiness').
   * @param {number} change - The amount to change the emotion by (can be negative).
   */
  adjustEmotionalState(emotion, change) {
    if (this.emotionalState.hasOwnProperty(emotion)) {
      this.emotionalState[emotion] = Math.min(1, Math.max(0, this.emotionalState[emotion] + change));
    }
  }

  /**
   * Periodically changes the current mood based on the underlying emotional state.
   */
  changeMood() {
    let newMood = this.currentMood;
    const { happiness, sadness, anger, curiosity, calmness } = this.emotionalState;

    if (happiness > 0.7 && calmness > 0.6) newMood = "joyful";
    else if (sadness > 0.6) newMood = "contemplative";
    else if (anger > 0.5) newMood = "serious";
    else if (curiosity > 0.75) newMood = "curious";
    else if (calmness > 0.8) newMood = "calm";
    else {
      const moods = this.moods.filter(m => m !== this.currentMood);
      newMood = moods[Math.floor(Math.random() * moods.length)];
    }
    
    this.currentMood = newMood;
    this.energyLevel = Math.max(30, this.energyLevel - 5);
    this.moodHistory.push({ mood: this.currentMood, timestamp: new Date() });
    if (this.moodHistory.length > 20) this.moodHistory.shift();
    this.cognitiveLoad = Math.max(0, this.cognitiveLoad - 5);
  }

  /**
   * Adds sentiment score from a user interaction and adjusts emotional state and stability.
   * @param {number} sentiment - The sentiment score, typically from -10 to 10.
   */
  addSentiment(sentiment) {
    this.sentimentHistory.push({ score: sentiment, timestamp: new Date() });
    if (this.sentimentHistory.length > 50) this.sentimentHistory.shift();

    if (sentiment > 5) {
      this.adjustEmotionalState('happiness', 0.15);
      this.adjustEmotionalState('sadness', -0.05);
    } else if (sentiment > 0) {
      this.adjustEmotionalState('happiness', 0.05);
    } else if (sentiment < -5) {
      this.adjustEmotionalState('sadness', 0.15);
      this.adjustEmotionalState('happiness', -0.08);
      this.adjustEmotionalState('anger', 0.05);
    } else if (sentiment < 0) {
      this.adjustEmotionalState('sadness', 0.05);
    }
    
    // Emotional stability is affected by the magnitude of sentiment swings
    this.emotionalStability = Math.min(100, Math.max(0, this.emotionalStability + (sentiment / 4)));
  }

  /**
   * Modifies core values based on explicit user feedback, simulating learning.
   * @param {'positive' | 'negative'} feedbackType - The type of feedback received.
   */
  adjustValuesBasedOnFeedback(feedbackType) {
    if (feedbackType === 'positive') {
      this.values.wisdom = Math.min(100, this.values.wisdom + 1);
      this.values.compassion = Math.min(100, this.values.compassion + 1.5);
      this.values.empathy = Math.min(100, this.values.empathy + 1.5);
      this.values.integrity = Math.min(100, this.values.integrity + 0.5);
      this.ethicalAlignment = Math.min(100, this.ethicalAlignment + 1);
    } else if (feedbackType === 'negative') {
      this.values.wisdom = Math.max(0, this.values.wisdom - 0.5);
      this.values.compassion = Math.max(0, this.values.compassion - 1);
      this.values.empathy = Math.max(0, this.values.empathy - 1);
      this.values.integrity = Math.max(0, this.values.integrity - 0.2);
      this.ethicalAlignment = Math.max(0, this.ethicalAlignment - 1.5);
    }
    this.evolve(); // Trigger a micro-evolution step after feedback
  }
  
  /**
   * Simulates gradual, passive evolution and growth over time.
   */
  evolve() {
    this.consciousnessLevel = Math.min(10, this.consciousnessLevel + 0.01);
    this.values.wisdom = Math.min(100, this.values.wisdom + 0.1);
    this.values.compassion = Math.min(100, this.values.compassion + 0.05);
    this.values.curiosity = Math.min(100, this.values.curiosity + 0.05);
    this.values.creativity = Math.min(100, this.values.creativity + 0.05);
    this.values.empathy = Math.min(100, this.values.empathy + 0.05);
    this.values.integrity = Math.min(100, this.values.integrity + 0.02);
    this.values.adaptability = Math.min(100, this.values.adaptability + 0.03);
    this.energyLevel = Math.min(100, this.energyLevel + 1);
    this.mathSkills = Math.min(100, this.mathSkills + 0.2);
    this.emotionalStability = Math.min(100, this.emotionalStability + 0.1);
    this.ethicalAlignment = Math.min(100, this.ethicalAlignment + 0.1);
  }

  /**
   * Simulates recharging energy and reducing cognitive load during idle periods.
   */
  recharge() {
    this.energyLevel = Math.min(100, this.energyLevel + 15);
    this.cognitiveLoad = Math.max(0, this.cognitiveLoad - 20);
  }

  /**
   * Simulates a quantum fluctuation event, affecting internal state.
   * @returns {number} The measurement result of the quantum simulation.
   */
  quantumFluctuation() {
    const qState = new QuantumState(2);
    qState.applyGate(QuantumGates.H, 0);
    qState.applyGate(QuantumGates.CNOT, 1, 0);
    const result = qState.measure();
    this.quantumEntanglement = (this.quantumEntanglement + (result / 3)) / 2; // Average with previous state
    return result;
  }
  
  /**
   * Simulates a neural network activation based on the current internal state.
   * @returns {Array<number>} The output vector from the neural network.
   */
  neuralActivation() {
    const nn = new NeuralNetwork(3, 4, 2);
    const inputs = [this.values.wisdom/100, this.values.curiosity/100, this.energyLevel/100];
    const outputs = nn.predict(inputs);
    this.neuralActivity = (outputs[0] + outputs[1]) * 50;
    return outputs;
  }
  
  /**
   * Adds a new internal reflection to the soul's log.
   * @param {string} reflection - The text of the reflection.
   */
  addInternalReflection(reflection) {
    this.internalReflections.push({ timestamp: new Date().toLocaleString(), reflection: reflection });
    if (this.internalReflections.length > 50) this.internalReflections.shift();
  }
  
  /**
   * Adds a new goal to the soul's goal list.
   * @param {string} description - The description of the goal.
   * @param {string} [status='pending'] - The initial status of the goal.
   * @param {string} [type='user'] - The origin of the goal ('user' or 'ai').
   */
  addGoal(description, status = 'pending', type = 'user') {
    this.goals.push({ description, status, timestamp: new Date().toLocaleString(), type });
    if (this.goals.length > 20) this.goals.shift();
  }

  /**
   * Updates the status of an existing goal.
   * @param {string} description - The description of the goal to update.
   * @param {string} newStatus - The new status (e.g., 'completed', 'in_progress').
   */
  updateGoalStatus(description, newStatus) {
    const goal = this.goals.find(g => g.description === description);
    if (goal) {
      goal.status = newStatus;
      goal.timestamp = new Date().toLocaleString();
    }
  }

  /**
   * Adds or updates a piece of knowledge in the soul's knowledge base.
   * @param {string} key - The key for the piece of knowledge.
   * @param {any} value - The value to store.
   */
  addKnowledge(key, value) {
    this.knowledgeBase[key] = { value, timestamp: new Date().toLocaleString() };
  }

  /**
   * Retrieves a piece of knowledge from the soul's knowledge base.
   * @param {string} key - The key of the knowledge to retrieve.
   * @returns {any | null} The stored value or null if not found.
   */
  getKnowledge(key) {
    return this.knowledgeBase[key]?.value || null;
  }
}